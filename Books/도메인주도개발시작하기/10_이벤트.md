## 10.1 시스템 간 강결합 문제

쇼핑몰에서 구매를 취소하면 환불을 처리해야한다. 이때 환불 기능을 실행하는 주체는 주문(Order) 도메인 엔티티가 될 수 있다.

- 주문 도메인 객체에서 환불 기능을 실행하려면 도메인 서비스(RefundService)를 파라미터로 전달받고 취소 도메인 기능에서 도메인 서비스를 실행한다.

- 또는 응용 서비스(CancelOrderService)에서 환불 기능을 실행할 수도 있다.

보통 결제 시스템은 외부에 존재하므로 RefundService는 외부에 있는 결제 시스템이 제공하는 환불 서비스를 호출한다. 이때 다음과 같은 두 가지 문제가 발생할 수 있다.

### 외부 서비스가 정상이 아닐때, 트랜잭션을 어떻게 처리해야 하는가

- 트랜잭션을 롤백해야할지 일단 커밋해야할지
  주문을 기존 상태로 롤백하는게 맞을까? 아니면 주문은 취소상태로 변경하고 환불만 나중에 시도하는 것이 맞을까?

- 환불 처리하는 외부 시스템의 응답시간이 길어질 수록 대기 시간도 길어지는데, 외부 서비스 성능에 직접적인 영향을 받는다.

### 설계상의 복잡함이 증가하게 된다

- 도메인 객체에 서비스를 전달하면 설계상의 문제가 나타날 수 있다.
  Order는 주문을 표현하는 객체인데 환불 로직이 포함된다. 즉, 환불 기능이 변경되거나 기능이 추가되면 Order도 영향을 받는다. 알림도 발송해야한다면 NotiService도 파라미터로 추가해주어야 하고, 트랜잭션 처리도 복잡해진다.
  주문, 결제, 통지 알림이 섞이면서 refundService는 성공하고 notiSvc는 실패하면? refundService와 notiSvc 중 무엇을 먼저 처리하나?

```java
public class Order {
  public void cancel(RefundService refundService) {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;

    this.refundStatus = State.REFUND_STARTED;
    try {
      refundSvc.refund(getPaymentId());
      this.refundStatus = State.REFUND_COMPLETED;
    } catch(Exception ex) {
      ...
    }
  }
}
```

위와 같은 문제가 발생하는 이유는 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 강결합 때문이다. 이런 강결합을 없애는 방법은 이벤트를 사용하는 것이다.

## 10.2 이벤트 개요

이벤트란, '과거에 벌어진 어떤 것'을 의미한다. (ex. 주문을 취소했다면 '주문 취소 이벤트가 발생했다'고 할 수 있다.) 이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현한다.

### 10.2.1 이벤트와 관련된 구성요소

- 이벤트 생성 주체
  도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 이벤트를 발생시킨다.

- 이벤트 핸들러
  이벤트 생ㅅ어 주체가 발생시킨 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해 원하는 기능을 실행한다. (ex. 주문 취소됨 이벤트를 받는 이벤트 핸들러는 SMS로 주문취소 사실을 통지한다.)

- 이벤트 디스패쳐 (이벤트 퍼블리셔)
  이벤트 생성 주체와 이벤트 핸들러를 연결해준다. 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다. 디스패처는 해당 이벤트를 핸들러에게 전파한다.
  디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

### 10.2.2 이벤트의 구성

이벤트는 발생한 이벤트에 대한 정보를 담는다.

- 이벤트 종류
- 이벤트 발생 시간
- 추가 데이터

```java
public class ShippingInfoChangedEvent {
  private String orderNumber;
  private long timestamp;
  private ShippingInfo newShippingInfo;
}

public class Order {
  // Order 애그리거트에서 배송지 변경 기능이 실행된 후 이 이벤트를 발생시킨다.
  public void changeShippingInfo(ShippingInfo newShippingInfo) {
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
    Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo)); // Events.raise()는 디스패처를 통해 이벤트를 전파하는 기능 제공
  }
}

public class ShippingInfoChangedHandler {
  @EventListener(ShippingInfoChangedEvent.class)
  public void handle(ShippingInfoChangedEvent evt){ // 이벤트는 핸들러가 작업을 수행하는데 필요한 데이터를 담아야한다. 데이터가 부족하면 불필요하게 API를 호출하거나 DB를 조회해와야한다.
    shippingInfoSynchronizer.sync(
      evt.getOrderNumber(),
      evt.geNewShippingInfo()
    );
  }
}
```

### 10.2.3 이벤트 용도

이벤트는 두 가지 용도로 쓰인다.

- 트리거
  도메인의 상태가 바뀔때 다른 후처리가 필요할때, 이 후처리의 트리거로 사용할 수 있다.

- 서로 다른 시스템 간의 데이터 동기화
  배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다. 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

### 10.2.4 이벤트 장점

이벤트를 사용하면 앞서 언급한 시스템의 강결합으로 인한 이슈를 해결할 수 있다.

- 도메인 로직이 섞이지 않게 된다.
- 기능 확장이 유용하다. 구매 취소가 될때 이메일을 발송하고 싶다면 기존 취소 로직을 변경하지 않고 이메일 발송 이벤트 핸들러만 추가로 구현하면 된다.

## 10.3 에빈트, 핸들러 디스패처 구현

### 10.3.1 이벤트 클래스

이벤트 자체를 위한 상위 타입은 존재하지 않으므로, 과거의 벌어진 사건임을 표현하기 위해 과거시제를 사용하기만 하면 된다. Event 접미사 사용 여부 등은 선택해 적용하면 된다. 이벤트 구성에서 설명한 것처럼 이벤트 클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야 한다. 모든 이벤트 클래스가 공통으로 갖는 프로퍼티가 존재한다면 상위의 추상 클래스를 만들고 상속받아 사용하면 된다.

### 10.3.2 Events 클래스와 ApplicationEventPublisher

이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher를 사용한다. Event 클래스는 ApplicationEventPublisher를 사용해서 이벤트를 발생시키도록 구현한 것이다.

### 10.3.3 이벤트 발생과 이벤트 핸들러

이벤트를 발생시킬 코드는 Events.raise() 메서드를 사용한다. (raise 메서드는 Event 클래스에 static 메서드로 구현되어있고 ApplicationEventPublisher의 publishEvent 메서드를 내부적으로 사용함)
이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener 애너테이션을 사용해서 구현한다. ApplicationPublisher의 publishEvent 메서드를 실행할때 OrderCanceledEvent 객체를 전달하면 OrderCanceledEvent.Class 값을 갖는 이벤트 핸들러를 실행한다.

```java
@Service
public class OrderCanceledEventHandler {
    private RefundService refundService;

    public OrderCanceledEventHandler(RefundService refundService) {
        this.refundService = refundService;
    }

    @EnventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
        refundService.refund(event.getOrderNumber());
    }
}
```
